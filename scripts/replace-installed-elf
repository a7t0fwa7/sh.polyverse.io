#!/bin/bash

# set the environment variable PV_BASE_URL to test non-prod version
if [ -z "$PV_BASE_URL" ]; then PV_BASE_URL="https://sh.polyverse.io"; fi

if [ -z "$(echo $SHELL | grep bash)" ]; then
	(>&2 echo "This script must be run with bash. Usage: curl $PV_BASE_URL | bash -s replace-installed")
	exit 1
fi

main() {
	# process command-line arguments; sets environment variables.
	parseCommandLine "$@"
	if [ $? -ne 0 ]; then return 1; fi

	checkPrerequisites
	if [ $? -ne 0 ]; then return 1; fi

	# call sh.polyverse.io's info script; results are exported as environment variables
	exportInfo
	if [ $? -ne 0 ]; then return 1; fi

	case "$DISTRO" in
		ubuntu)
			apt_replaceInstalledElf
			if [ $? -ne 0 ]; then return 1; fi
			;;
		*)
			_echo "This script doesn't currently support distro '$DISTRO'."
			return 1
			;;
	esac

	return 0
}

parseCommandLine() {
	if [ "$1" = "replace-installed-elf" ]; then
		shift
	fi

	while [ $# -gt 0 ]; do
		case "$1" in
			--package)
				shift
				export PV_PACKAGE_LIST="$PV_PACKAGE_LIST $1"
				;;
			--log)
				shift
				export PV_LOGFILE="$1"
				;;
			*)
				_echo "Error: unexpected argument '$1'."
				return 1
				;;
		esac
		shift
	done

	if [ -z "$PV_LOGFILE" ]; then
		export PV_LOGFILE="/var/log/polyverse.log"
	fi

	if [ ! -f "$PV_LOGFILE" ]; then
		touch "$PV_LOGFILE"
	fi
}

checkPrerequisites() {
	if [ $(id -u) -ne 0 ]; then
		_echo "This script must be run as root. Please try running this again with sudo or as a root user."
		return 1
	fi

	curl >/dev/null 2>&1
	if [ $? -eq 127 ]; then
		_echo "This script requires curl. Please install it and try running this again."
		return 1
	fi

	return 0
}

exportInfo() {
	_INFO="$(_eval "curl -s $PV_BASE_URL/main.sh | PV_BASE_URL=$PV_BASE_URL sh -s info")"
	if [ $? -ne 0 ]; then
		_echo "Unable to determine Linux distro info: $_INFO. Please contact support@polyverse.io."
		return 1
	fi

	for _LINE in $_INFO; do
		export $(echo $_LINE)
	done

	return 0
}

isELF() {
	file $1 2>/dev/null | grep -q " ELF "
	return $?
}

apt_replaceInstalledElf() {
	if [ -z "$(cat /etc/apt/sources.list | grep -v ^# | fgrep "repo.polyverse.io")" ]; then
		_echo "Error: It appears that Polymorphic Linux has not been installed yet. Please install first and then re-run this script."
		return 1
	fi

	# comment-out all the lines in sources.list except for the ones from repo.polyverse.io
	_eval "sed -in '/repo.polyverse.io/! s/^/#/' /etc/apt/sources.list"
	if [ $? -ne 0 ]; then return 1; fi

	# run apt-get update so we only use the repo.polyverse.io index files
	_eval "apt-get update -y 2>/dev/null"
	if [ $? -ne 0 ]; then return 1; fi

	# revert the commenting-out in sources.list in case the script is killed before the end
	_eval "sed -in 's/^#//g' /etc/apt/sources.list"
	if [ $? -ne 0 ]; then return 1; fi

	# install the 'file' package if it isn't already installed; needed to determine if a file is ELF.
	_eval "file --version >/dev/null 2>&1"
	if [ $? -eq 127 ]; then
		_eval "apt-get install -y file"
		if [ $? -ne 0 ]; then return 1; fi
	fi

	if [ -z "$PV_PACKAGE_LIST" ]; then
		# output of 'apt list --installed' looks like:
		#
		#   adduser/xenial,now 3.113+nmu3ubuntu4 all [installed]
		#   apt/xenial-updates,now 1.2.29ubuntu0.1 amd64 [installed]
		#   apt-transport-https/xenial-updates,now 1.2.29ubuntu0.1 amd64 [installed]
		#
		APT_LIST_INSTALLED="$(_eval "apt list --installed 2>/dev/null | fgrep \"[installed\"")"

		# transform output to "adduser=3.113+nmu3ubuntu4 apt=1.2.29ubuntu0.1 apt-transport-https=1.2.29ubuntu0.1"
		export PV_PACKAGE_LIST="$(_eval "echo \"$APT_LIST_INSTALLED\" | sed 's/ /\//g' | awk -F/ '{print \$1\"=\"\$3}' | xargs")"
	fi

	# apt-get download downloads to current directory, so cd to a permissive folder
	cd /tmp

	_eval "mkdir -p /tmp/pv/info"
	if [ $? -ne 0 ]; then return 1; fi

	for PACKAGE in $PV_PACKAGE_LIST; do
		_echo "Processing '$PACKAGE' ..."

		_eval "apt-get download $PACKAGE 2>&1"
		if [ $? -ne 0 ]; then
			_echo "Info: Polymorphic version of '$PACKAGE' unavailable. Skipping."
			continue
		fi

		DEB_FILENAME="$(echo "$PACKAGE" | awk -F= '{print $1}')_$(echo "$PACKAGE" | awk -F= '{print $2}')"
		DEB_FILENAME="$(ls /tmp/$(encodeFilename $DEB_FILENAME)_*.deb 2>/dev/null | xargs)"
		if [ -z "$DEB_FILENAME" ]; then
			_echo "Warning: Unable to determine downloaded .deb filename for package '$PACKAGE'. Skipping."
			continue
		fi

		deb_installElfsOnly $DEB_FILENAME
	done

	_eval "rm -frd /tmp/pv 2>/dev/null"

	# after restoring (un-commenting) sources.list, we haven't updated the index since
	_eval "apt-get update -y 2>/dev/null"

	return 0
}

deb_installElfsOnly() {
		_DEB_FILENAME="$1"
		_PKG_NAME="$(echo "$_DEB_FILENAME" | sed 's/\/tmp\///g' | sed 's/_.*//g')"

		if [ ! -f "$_DEB_FILENAME" ]; then
			_echo "Warning: file '$_DEB_FILENAME' missing."
			return 1
		fi

		_eval "rm -frd $_DEB_FILENAME~ && mkdir $_DEB_FILENAME~"
		_eval "dpkg-deb -R $_DEB_FILENAME $_DEB_FILENAME~"
		while IFS= read -r _FILE; do
			if [ $(isELF $_FILE; echo $?) -eq 0 ]; then
				_log "Leaving '$_FILE'."
				_FILE2="$(echo "$_FILE" | sed 's|'${_DEB_FILENAME}~\/'||g')"
				updateChecksumFile $_FILE2 $_PKG_NAME $_DEB_FILENAME~/DEBIAN/md5sums
				continue
			fi
			if [ "$_FILE" = "$_DEB_FILENAME~/DEBIAN/control" ] || [ "$_FILE" = "$_DEB_FILENAME~/DEBIAN/md5sums" ]; then
				_log "Leaving '$_FILE'."
				continue
			fi

			_log "Removing '$_FILE'."
			_eval "rm -f \"$_FILE\""
		done <<< "$(find $_DEB_FILENAME~ -not -type d)"

		# since we remove a bunch of files, there are probably empty folders that we should remove before packaging
		_DIRECTORIES="$(find $_DEB_FILENAME~ -type d)"
		for _DIRECTORY in $_DIRECTORIES; do
			_log "Processing directory '$_DIRECTORY'..."
			if [ -z "$(find $_DIRECTORY -type f 2>/dev/null)" ]; then
				_log "Removing directory '$_DIRECTORY'..."
				_eval "rm -frd $_DIRECTORY"
			fi
		done

		# build the stripped (ELF files only) .deb file
		_eval "dpkg-deb -b $_DEB_FILENAME~ $_DEB_FILENAME"

		# create the .list file
		LISTFILE="$(ls /var/lib/dpkg/info/${_PKG_NAME}[.:]*list 2>/dev/null)"
		if [ -z "$LISTFILE" ]; then
			LISTFILE="/var/lib/dpkg/info/${_PKG_NAME}.list"
		fi

		# move all the package's metadata from /var/lib/dpkg/info to a temp folder
		_eval "mv /var/lib/dpkg/info/${_PKG_NAME}[.:]* /tmp/pv/info 2>/dev/null"

		# create the .list file that corresponds to the contents of this abridged .deb file
		_eval "dpkg-deb -c $_DEB_FILENAME | awk {'print \$6'} | cut -f2- -d. | sed 's|^/\$|/.|' | sed 's|/\$||' > $LISTFILE"

		# install the .deb file; files in the .deb file are placed in their target location
		_eval "dpkg --install $_DEB_FILENAME"
		if [ $? -ne 0 ]; then return 1; fi

		# clean-up
		_eval "mv /tmp/pv/info/${_PKG_NAME}[.:]* /var/lib/dpkg/info/ 2>/dev/null"
		_eval "rm -frd $_DEB_FILENAME~ 2>/dev/null"
		_eval "rm -f ${_DEB_FILENAME} >/dev/null 2>&1"
		if [ $? -ne 0 ]; then return 1; fi
}

updateChecksumFile() {
	_FILENAME="$1"
	_PACKAGE_NAME="$2"
	_SOURCE_MD5_FILE="$3"

	_TARGET_MD5_FILE="$(ls /var/lib/dpkg/info/${_PACKAGE_NAME}[.:]*md5sums)"

	# 971c13bfde62ca04cfb42f740e44b262  bin/kill
	# 971c13bfde62ca04cfb42f740e44b262  usr/bin/skill

	_SOURCE_MD5="$(cat $_SOURCE_MD5_FILE | grep " $_FILENAME\$" 2>/dev/null)"
	if [ -z "$_SOURCE_MD5" ]; then
		# special handling for things that break greg regex like "usr/bin/[" results in "grep: Unmatched [ or [^"
		_SOURCE_MD5="$(cat $_SOURCE_MD5_FILE | fgrep " $_FILENAME" 2>/dev/null)"
	fi
	_TARGET_MD5="$(cat $_TARGET_MD5_FILE | grep " $_FILENAME\$" 2>/dev/null)"
	if [ -z "$_TARGET_MD5" ]; then
		_TARGET_MD5="$(cat $_TARGET_MD5_FILE | fgrep " $_FILENAME" 2>/dev/null)"
	fi

	_log "_FILENAME: $_FILENAME, _PACKAGE_NAME: $_PACKAGE_NAME, _SOURCE_MD5_FILE: $_SOURCE_MD5_FILE, _SOURCE_MD5: $_SOURCE_MD5, _TARGET_MD5_FILE: $_TARGET_MD5_FILE, _TARGET_MD5: $_TARGET_MD5"

	if [ ! -z "$_SOURCE_MD5" ] && [ ! -z "$_TARGET_MD5" ]; then
		_eval "sed -i 's/$(sedEscape "$_TARGET_MD5")/$(sedEscape "$_SOURCE_MD5")/g' $_TARGET_MD5_FILE"
		return $?
	fi

	return 1
}

encodeFilename() {
	_str="$1"
	_str="$(echo "$_str" | sed 's/:/%3a/g')"
	echo "$_str"
}

sedEscape() {
	_str="$1"
	_str="$(echo "$_str" | sed 's/\//\\\//g')"
	_str="$(echo "$_str" | sed 's/\[/\\\[/g')"
	echo "$_str"
}

_echo() {
	if [ -z "$PV_LOGFILE" ]; then
		echo -e "$1" >&2
	else
		echo -e "$1" | tee -a $PV_LOGFILE >&2
	fi
}

_debugln() { 
	if [ ! -z "$PV_DEBUG" ]; then
		_echo "PV_DEBU: $1"
	fi
}

_log() {
	echo -e "$1" >> $PV_LOGFILE
}

_eval() {
	_log "_eval() \$1:\"$1\""

	if [ -z "$PV_LOGFILE" ]; then
		_echo "PV_LOGFILE global variable is empty."
		return 1
	fi

	# https://stackoverflow.com/questions/692000/how-do-i-write-stderr-to-a-file-while-using-tee-with-a-pipe
	eval "$1" > >(tee -a $PV_LOGFILE) 2> >(tee -a $PV_LOGFILE >&2)
	_EXITCODE=$?

	_log "_eval() \$_EXITCODE: $_EXITCODE"

	return $_EXITCODE
}

main "$@"
exit $?
